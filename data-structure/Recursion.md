# 재귀 호출

---

<aside>
💡 재귀 호출이란? → 자기 자신을 다시 호출하는 것.

</aside>

**재귀호출을 사용하는 이유**

---

1. 비 선형 자료구조에서 쓰이기 때문. 그래프나 트리 같은 비선형 자료구조를 탐색하는데 재귀 호출을 사용한다.
2. 복잡한 문제를 쉽게 해결하기 위한 문제 해결 기법. 복잡한 문제를 작고 단순한 문제로 나누어 해결하는 **분할정복** 에 쓰인다.

### 🐘재귀 호출의 2가지 조건

---

재귀 호출에서는 함수가 자신을 무한대로 호출하지 않도록 무한 루프를 탈출하는 조건이 필요하다.  

재귀 호출을 구현할 때는 아래와 같은 2가지 원칙을 반드시 지켜야 한다.

<aside>
💡  1. 호출 시 마다 문제의 범위가 줄어들어야 한다.

1. 종료 조건이 있어야 한다.
</aside>

아래는 자기 자신을 호출하는 함수인 재귀함수 my_func() 코드이다.

```cpp
int my_func(int input_value) {

	int ret=0;
	ret = input1 + my_func( input_value -1 );

	return ret;
}
```

위 코드에서 my_func()는 자기 자신을 호출할 때 매개변수의 값이 -1 된다. 

이렇게 my_func()는 호출될 때마다 문제의 범위가 줄어드는것을 확인했다.

 

### 🐳**무한 루프 해결**

---

**팩토리얼**

```cpp
int factorial(int n) {
	
	int ret = 0;
	if (n <=1) 
	{
	ret =1;
	}
else
	{
	ret = n*factorial(n-1);
	}
return ret;
}
```

위 코드는 팩토리얼 코드이다.

else 문에서 자기 자신을 호출할 때 매개변수로 n-1을 받는다. 문제의 범위가 좁혀짐을 알 수 있다.

또한 무한루프를 해결하기 위한 조건도 만족시키고있다.

if 문 안을 보자.

n이 계속 1씩 감소하다가, 1과 같거나 작아지게 되면 ret 값을 1로 설정하고, ret 을 반환한다.

따라서 자기 자신을 호출하지 않고 종료하므로 무한루프에 빠지지 않는다.

### 팩토리얼 함수의 실행 과정

---

위 코드의 실행 과정을 알아보자.

1. factorial(3)이 호출된다고 가정하자. 인수로 3을 받은 factorial 함수가 실행되다가, else 문에서 1 감소한 2를 인수로 받는 factorial(2)가 호출된다. 이 때 factorial(3)의 실행은 아직 끝나지 않았다. 
2. factorial(2)가 실행 된다. 여전히 if 문을 만족시키지 않으므로 else 문이 실행되고, 인수가 1 감소한 factorial(1)을 호출한다. 여전히 factorial(2)는 끝나지 않았다. factorial(3)도 마찬가지다.
3. factorial(1)이 실행된다. if 문을 만족시키므로 1을 반환하고 함수가 종료된다. 그 다음 차례대로 factorial(2),factorial(3)이 종료된다.

🏊🏻**문맥 변경?**

---

OS 관점에서 문맥 변경(Context switch) 란, 프로세스의 상태 정보를 교환하는 작업이다.

어떤 프로세스가 CPU를 사용하고 있는데, 다른 프로세스가 CPU를 사용하도록 하기 위해 현재 실행중이던 프로세스를 PCB ( 프로세스 제어 블록) 에 보관하고, 다른 프로세스를 실행하는 과정이다.

위 팩토리얼 함수에서 문맥 변경이란, factorial(1),  factorial(2),  factorial(3) 은 모두 다른 함수로 취급되고, 각각의 함수들을 위한 활성 레코드가 생성되어 관리된다.

### 🐴재귀 호출의 단점

---

1. 속도가 상대적으로 느리다. 문맥 변경에 추가적인 시간이 필요하다.
2. 함수 호출 횟수에 제한이 있다. OS의 스택 크기에 재한이 있다.

### 💆🏻재귀 vs 반복

---

반복이란, 재귀 호출과 반대되는 개념이다. for 나 while 문 같은 반복문으로 명령을 실행해 문제를 해결한다.

| 구분 | 재귀 | 반복 |
| --- | --- | --- |
| 장점 | 알고리즘이 간결하고 명확함 | 속도가 빠름, 메모리 사용이 작음 |

반복문은 함수가 커져도 루프의 수행 횟수가 많아지는 것이지, 함수를 여러 번 호출하는게 아니기 때문에 메모리를 적게 사용한다.

재귀와 반복은 표현 능력이 서로 같다. 따라서 재귀로 구현된 함수를 반복으로 구현할 수 있다.

아래는 팩토리얼 코드를 반복으로 구현한 코드이다.

```cpp
int factorial_iter(int n) {
	int ret=1;
	int i =1;
	
	for(i = n; i>1; i++) {
		ret = ret * i;
}

return ret;
}
```

### 피보나치 수열

---

피보나치 수열이란, 첫째항과 둘째항을 제외한 항들이 바로 이전항과 이전항의 이전항을 더한 값을 값으로 가지는 수열이다.

그러니까 첫째, 둘째 항이 0과 1이라면 세번째 항 부터는 0과 1을 더한 1, 네번째 항은 1과 1을 더한  2,다섯번째 항은 2와 1을 더한 3,,,,이런식으로 정의된다.

수열의 정의 자체가 재귀로 구현되어 있으므로 재귀로 구현하기 직관적이고, 쉽다. 아래는 재귀로 구현한 피보나치 수열이다.

```cpp
int fib(int n) }
	
	int ret=0;

	if(n==0) {

		ret =0;
	}
	else if (n==1) {
		ret =1;
	}
	else {
		ret = fib(n-1) + fib(n-2);
	}

	return ret;
}
		
```

위 코드에서 else 문 내부가 피보나치 수열을 재귀 호출하는 내용이다.

fib(n)에서 인수로 전달받은 수보다 전, 이전 항의 값을 더해서 ret에 저장하고 함수를 종료한다.

그런데 여기서  문제가 있다.

![Untitled](%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%20%E1%84%92%E1%85%A9%E1%84%8E%E1%85%AE%E1%86%AF%20136a015f51254956b09a186de7c602b2/Untitled.png)

위 그림은 fib(6)을 실행했을 때, 호출되는 함수들이다.

fib(4)는 한번만 호출되면 되는데, fib(5)의 재귀호출에 의해 한번 더 실행되었다.

fib(3) 또한 한 번만 호출되면 되는데, fib(5)와 fib(4)에 의해 3번이나 호출되었다.

2와 1,0 은 더 많이 호출되었다. 

 이런식으로 피보나치 수열을 재귀로 구현하면 불필요한 함수 호출이 많아져서 시간복잡도가 지수적으로 증가한다.

아래 코드는 이런 문제를 해결하기 위해 피보나치 수열은 반복적인 방법으로 해결한다.

```cpp
int fib_iter(int n) {
	int ret=0;

	if(n<2) {
		ret =n ;
	}

	else {
		int i=0,temp=0,current =1, last =0;

		for(i =2;i<=n; i++) {
			temp =current;
		current += last;
			last =temp;
}
		ret =current;
}
	return ret;
}
```

위 코드는 n이 2보다 클 때에 대해, for 루프를 반복하며 피보나치 함수의 값을 구한다. 

위에서 설명한 것 처럼 n이 커져도 반복을 여러번 할 뿐이지, 함수가 여러 번 호출되지 않으므로 fib_iter() 함수가 가지는 시간복잡도는 O(n)이다.  

함수를 한 번만 호출하므로 속도가 빠르고 메모리를 적게 사용하지만 알고리즘을 직관적으로 이해하기 어려운 단점이 있다.

아래 코드는 팩토리얼 함수를 자바스크립트로 변환한 코드이다.

![Untitled](%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%20%E1%84%92%E1%85%A9%E1%84%8E%E1%85%AE%E1%86%AF%20136a015f51254956b09a186de7c602b2/Untitled%201.png)

### 👨🏻‍🔧하노이의 탑

---

이전에 알아본 피보나치 수열은 반복적으로 해결하면 리소스를 절약할 수 있었다.

하노이의 탑은 반대로, 반복적으로 문제를 해결하기 어려운 예시이다.

![Untitled](%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%20%E1%84%92%E1%85%A9%E1%84%8E%E1%85%AE%E1%86%AF%20136a015f51254956b09a186de7c602b2/Untitled%202.png)

하노이의 탑은 위 그림처럼 왼쪽 막대기에 쌓여있는 원판들을 조건에 따라 이동시켜 가장 오른쪽 막대로 옮기는 알고리즘이다. 조건은 다음과 같다.

1. 한 번에 하나의 원판만 이동할 수 있다
2. 맨 위의 원판만 이동할 수 있다.
3. 작은 원판 위에 큰 원판이 있을 수 없다.
4. 중간 막대를 이용할 수 있으나, 위의 조건들을 만족시켜야 한다.

위 그림은 옮겨야 할 원판의 수가 그리 많지 않기 때문에 이해하는데 크게 어려움이 없다.

하지만 옮겨야 하는 원판의 수가 많아질수록, 직관적으로 문제를 해결하기가 매우 어렵다.

아래는 하노이의 탑 C언어 코드이다.

```jsx
#include<stdio.h>

void hanoi_tower(int n, char from, char temp, char to) {

	if(n==1) {

		printf("원판 1을 %c에서 %c로 옮깁니다\n.",from,to);
}
	else 
{
	hanoi_tower(n-1,from,to,temp);
	printf("원판 %i를 %c에서 %c로 옮겼습니다.\n",n,from,to);
	hanoi_tower(n-1,temp,from,to);
	}
}

int main(int arc, char **argv) {
	char from = 'A';
	char temp ='B';
	char to ='C';

	hanoi_tower(4,from,temp,to) ;

	return 0;
}
```

위 코드를 보면 하노이의 탑 함수는 재귀호출이 이루어진다.  그런데 재귀 호출이 이루어지는 위치가 함수의 머리와 꼬리에서 이루어지기 때문에 반복으로 변경하기 힘들다.

따라서 하노이의탑은 반복보다 재귀의 방법으로 해결하는게 효율적이다.